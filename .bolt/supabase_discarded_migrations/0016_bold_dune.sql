-- Drop and recreate auth schema with proper setup
DROP SCHEMA IF EXISTS auth CASCADE;
CREATE SCHEMA auth;

-- Required extensions
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pgcrypto";

-- Grant schema permissions
GRANT USAGE ON SCHEMA auth TO postgres, anon, authenticated, service_role;

-- Create auth.users table with all required fields
CREATE TABLE auth.users (
    instance_id uuid DEFAULT uuid_generate_v4(),
    id uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
    aud varchar(255) DEFAULT 'authenticated',
    role varchar(255) DEFAULT 'authenticated',
    email varchar(255) UNIQUE,
    encrypted_password varchar(255),
    email_confirmed_at timestamptz DEFAULT now(),
    last_sign_in_at timestamptz DEFAULT now(),
    raw_app_meta_data jsonb DEFAULT '{"provider":"email","providers":["email"]}'::jsonb,
    raw_user_meta_data jsonb DEFAULT '{}'::jsonb,
    is_super_admin boolean DEFAULT false,
    created_at timestamptz DEFAULT now(),
    updated_at timestamptz DEFAULT now(),
    confirmation_token varchar(255) DEFAULT '',
    email_change_token_current varchar(255) DEFAULT '',
    email_change_token_new varchar(255) DEFAULT '',
    recovery_token varchar(255) DEFAULT ''
);

-- Create auth.sessions table
CREATE TABLE auth.sessions (
    id uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id uuid REFERENCES auth.users(id) ON DELETE CASCADE,
    created_at timestamptz DEFAULT now(),
    updated_at timestamptz DEFAULT now()
);

-- Create auth.refresh_tokens table
CREATE TABLE auth.refresh_tokens (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    token text UNIQUE,
    user_id uuid REFERENCES auth.users(id) ON DELETE CASCADE,
    parent text,
    created_at timestamptz DEFAULT now(),
    updated_at timestamptz DEFAULT now(),
    session_id uuid REFERENCES auth.sessions(id) ON DELETE CASCADE
);

-- Create indexes
CREATE INDEX users_instance_id_idx ON auth.users(instance_id);
CREATE INDEX users_email_idx ON auth.users(email);
CREATE INDEX refresh_tokens_token_idx ON auth.refresh_tokens(token);
CREATE INDEX refresh_tokens_user_id_idx ON auth.refresh_tokens(user_id);
CREATE INDEX refresh_tokens_session_id_idx ON auth.refresh_tokens(session_id);

-- Grant table permissions
GRANT ALL ON ALL TABLES IN SCHEMA auth TO postgres, service_role;
GRANT SELECT, INSERT, UPDATE ON ALL TABLES IN SCHEMA auth TO authenticated;
GRANT SELECT ON ALL TABLES IN SCHEMA auth TO anon;

-- Grant sequence permissions
GRANT ALL ON ALL SEQUENCES IN SCHEMA auth TO postgres, service_role;
GRANT USAGE ON ALL SEQUENCES IN SCHEMA auth TO authenticated;

-- Create admin user with proper defaults
INSERT INTO auth.users (
    email,
    encrypted_password,
    raw_app_meta_data,
    raw_user_meta_data,
    is_super_admin,
    role
) VALUES (
    'admin@example.com',
    crypt('admin123', gen_salt('bf')),
    '{"provider":"email","providers":["email"]}',
    '{"is_admin":true}',
    true,
    'authenticated'
) ON CONFLICT (email) DO UPDATE SET
    encrypted_password = EXCLUDED.encrypted_password,
    raw_app_meta_data = EXCLUDED.raw_app_meta_data,
    raw_user_meta_data = EXCLUDED.raw_user_meta_data,
    is_super_admin = true,
    role = 'authenticated';